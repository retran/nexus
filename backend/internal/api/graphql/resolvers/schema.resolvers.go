package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	graphql1 "github.com/retran/nexus/backend/internal/api/graphql"
	"github.com/retran/nexus/backend/internal/api/graphql/model"
	"github.com/retran/nexus/backend/internal/repository/postgres"
)

// ID resolver for AuditLog.
func (r *auditLogResolver) ID(ctx context.Context, obj *postgres.AuditLog) (string, error) {
	return obj.ID.String(), nil
}

// UserID resolver for AuditLog.
func (r *auditLogResolver) UserID(ctx context.Context, obj *postgres.AuditLog) (*string, error) {
	if !obj.UserID.Valid {
		return nil, nil
	}
	id := uuid.UUID(obj.UserID.Bytes).String()
	return &id, nil
}

// User is the resolver for the user field.
func (r *auditLogResolver) User(ctx context.Context, obj *postgres.AuditLog) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Metadata resolver for AuditLog.
func (r *auditLogResolver) Metadata(ctx context.Context, obj *postgres.AuditLog) (*string, error) {
	if obj.Metadata == nil {
		return nil, nil
	}
	metadata := string(obj.Metadata)
	return &metadata, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: CreateUser - createUser"))
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// UpdateUserRole is the resolver for the updateUserRole field.
func (r *mutationResolver) UpdateUserRole(ctx context.Context, id string, input model.UpdateUserRoleInput) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: UpdateUserRole - updateUserRole"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// CreateAuditLog mutation.
func (r *mutationResolver) CreateAuditLog(ctx context.Context, input model.CreateAuditLogInput) (*postgres.AuditLog, error) {
	var pgUserID pgtype.UUID
	if input.UserID != nil {
		id, err := uuid.Parse(*input.UserID)
		if err != nil {
			return nil, err
		}
		pgUserID = pgtype.UUID{
			Bytes: id,
			Valid: true,
		}
	}

	var metadataBytes []byte
	if input.Metadata != nil {
		metadataBytes = []byte(*input.Metadata)
	}

	log, err := r.Queries.CreateAuditLog(ctx, postgres.CreateAuditLogParams{
		UserID:    pgUserID,
		EventType: postgres.AuditEventType(input.EventType),
		IpAddress: input.IPAddress,
		UserAgent: input.UserAgent,
		Metadata:  metadataBytes,
	})
	if err != nil {
		return nil, err
	}

	return &log, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: UserByEmail - userByEmail"))
}

// UserByKratosID is the resolver for the userByKratosId field.
func (r *queryResolver) UserByKratosID(ctx context.Context, kratosIdentityID string) (*postgres.User, error) {
	panic(fmt.Errorf("not implemented: UserByKratosID - userByKratosId"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*postgres.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// UsersByRole is the resolver for the usersByRole field.
func (r *queryResolver) UsersByRole(ctx context.Context, role postgres.UserRole, limit *int, offset *int) ([]*postgres.User, error) {
	panic(fmt.Errorf("not implemented: UsersByRole - usersByRole"))
}

// CountUsers is the resolver for the countUsers field.
func (r *queryResolver) CountUsers(ctx context.Context) (int, error) {
	count, err := r.Queries.CountUsers(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to count users: %w", err)
	}
	return int(count), nil
}

// CountUsersByRole is the resolver for the countUsersByRole field.
func (r *queryResolver) CountUsersByRole(ctx context.Context, role postgres.UserRole) (int, error) {
	panic(fmt.Errorf("not implemented: CountUsersByRole - countUsersByRole"))
}

// AuditLogs query.
func (r *queryResolver) AuditLogs(ctx context.Context, userID *string, eventType *postgres.AuditEventType, limit *int, offset *int) ([]*postgres.AuditLog, error) {
	limitVal := 50
	if limit != nil {
		limitVal = *limit
	}

	offsetVal := 0
	if offset != nil {
		offsetVal = *offset
	}

	var pgUserID pgtype.UUID
	if userID != nil {
		id, err := uuid.Parse(*userID)
		if err != nil {
			return nil, err
		}
		pgUserID = pgtype.UUID{
			Bytes: id,
			Valid: true,
		}
	}

	var eventTypeStr *string
	if eventType != nil {
		str := string(*eventType)
		eventTypeStr = &str
	}

	logs, err := r.Queries.ListAuditLogs(ctx, postgres.ListAuditLogsParams{
		UserID:    pgUserID,
		EventType: eventTypeStr,
		Limit:     int32(limitVal),
		Offset:    int32(offsetVal),
	})
	if err != nil {
		return nil, err
	}

	result := make([]*postgres.AuditLog, len(logs))
	for i := range logs {
		result[i] = &logs[i]
	}

	return result, nil
}

// AuditLog query.
func (r *queryResolver) AuditLog(ctx context.Context, id string) (*postgres.AuditLog, error) {
	parsedID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	log, err := r.Queries.GetAuditLogByID(ctx, parsedID)
	if err != nil {
		return nil, err
	}

	return &log, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *postgres.User) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// KratosIdentityID is the resolver for the kratosIdentityId field.
func (r *userResolver) KratosIdentityID(ctx context.Context, obj *postgres.User) (string, error) {
	panic(fmt.Errorf("not implemented: KratosIdentityID - kratosIdentityId"))
}

// AuditLog returns graphql1.AuditLogResolver implementation.
func (r *Resolver) AuditLog() graphql1.AuditLogResolver { return &auditLogResolver{r} }

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

// User returns graphql1.UserResolver implementation.
func (r *Resolver) User() graphql1.UserResolver { return &userResolver{r} }

type auditLogResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
