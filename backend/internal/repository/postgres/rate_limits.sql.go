// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rate_limits.sql

package postgres

import (
	"context"
	"time"
)

const CleanupExpiredRateLimits = `-- name: CleanupExpiredRateLimits :exec
DELETE FROM rate_limits
WHERE reset_at < NOW()
`

func (q *Queries) CleanupExpiredRateLimits(ctx context.Context) error {
	_, err := q.db.Exec(ctx, CleanupExpiredRateLimits)
	return err
}

const GetRateLimit = `-- name: GetRateLimit :one
SELECT key, attempts, reset_at FROM rate_limits
WHERE key = $1
`

func (q *Queries) GetRateLimit(ctx context.Context, key string) (RateLimit, error) {
	row := q.db.QueryRow(ctx, GetRateLimit, key)
	var i RateLimit
	err := row.Scan(&i.Key, &i.Attempts, &i.ResetAt)
	return i, err
}

const ResetRateLimit = `-- name: ResetRateLimit :exec
DELETE FROM rate_limits
WHERE key = $1
`

func (q *Queries) ResetRateLimit(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, ResetRateLimit, key)
	return err
}

const UpsertRateLimit = `-- name: UpsertRateLimit :one
INSERT INTO rate_limits (key, attempts, reset_at)
VALUES ($1, 1, $2)
ON CONFLICT (key) DO UPDATE
SET attempts = rate_limits.attempts + 1,
    reset_at = CASE
        WHEN rate_limits.reset_at < NOW() THEN $2
        ELSE rate_limits.reset_at
    END
RETURNING key, attempts, reset_at
`

type UpsertRateLimitParams struct {
	Key     string    `json:"key"`
	ResetAt time.Time `json:"reset_at"`
}

func (q *Queries) UpsertRateLimit(ctx context.Context, arg UpsertRateLimitParams) (RateLimit, error) {
	row := q.db.QueryRow(ctx, UpsertRateLimit, arg.Key, arg.ResetAt)
	var i RateLimit
	err := row.Scan(&i.Key, &i.Attempts, &i.ResetAt)
	return i, err
}
